---
title: 'The Biggest Takeaway from My Studies'
description: 'Reflecting on the biggest takeway from my 5 year studies'
date: '2025-07-30'
image: '/post-images/takeaways-from-studies/thumbnail.jpg'
categories:
  - blog
  - tutorial
published: true
---

## TL;DR

_Reading documentation._

Universities often teach abstract concepts, and you build things that you might not use explicitly when you start working. However, this requires you to read the documentation of what you're applying, because there are no tutorials that exist online (that are within the scope of the curriculum). This turned out to be quite helpful when learning new things in my day job.

## Background

During my studies, I would always hear how different applied software engineering is, compared to the theoretical concepts we learn in school. I'll be honest, I enjoyed learning the theoretical aspects of computer science, and building things that I would never build in a regular software engineering job.

However, there are things from my studies that I have come to appreciate in my day job. These are things we often don't think about while we're in school, but being conscious of these things allows us to actually use them to our advantage and be more prepared for real life.

## Just Read the Docs!

![tech docs](/post-images/takeaways-from-studies/Tech-docs.jpeg)
Yup. It's as simple as that.

This is perhaps the one thing I am the most thankful for. A persistent issue amongst junior devs is this so-called "tutorial hell" – you know, that endless cycle of watching tutorials and following step-by-step guides without really understanding what's happening.

The issue with this is that you could in theory build a lot of new things, and it would give you the illusion that you actually learned something. I'd watch a 5-minute intro to Haskell video, and could claim that I knew Haskell. But in reality, implementing anything outside the scope of that video would have me lost.

Well, one great thing about the abstract and theoretical nature of university is that we implement things that are either so fundamental to the core, that following a tutorial that applies the same concept might not help you in that situation. Another thing is that many assignments require you to implement specific things that have never been implemented by anyone outside of the scope of the course.

## What do you mean you can't find it online?

My biggest shock came from an assignment I had in an advanced algorithms course. We learned about time and space complexity, and writing proofs for NP-completeness.

For anyone who has had a similar course, you know that one of the first problems we learn is the [SAT problem](https://en.wikipedia.org/wiki/Boolean_satisfiability_problem), and its derived version 3-SAT. Well, our first assignment was quite different.

The example that is usually covered is the SAT problem, and its derived version 3-SAT. Well, what was our assignment? Implement 10-SAT.

The first thing we did was go to Google, because someone else must have solved this, right? Wrong! Only universities would require you to implement something like this. Why would anyone else implement this sort of stuff? This meant that we couldn't use anyone's solution as inspiration for our assignment. To solve this assignment we actually had to learn how NP-completeness proofs work, and how we could apply them. And for some reason, not a single NP-completeness tutorial was applicable to our assignment.

So there was no other way but to turn to the documentation.

## But we have LLMs now

With the emergence of LLMs, not only can we use them to teach us technologies, but they can also implement the boring stuff for us when we really don't want to go through the documentation.

Come to find out, LLMs were not always helpful. Either because they weren't up to date, or simply because of the hallucinations.

![llm](/post-images/takeaways-from-studies/llm.jpg)

I would spend more time fighting with the LLMs than I would if I had just read the docs to begin with. To my surprise, a lot of these docs cover what you're looking for in a more concise manner than the LLMs.

So even later during my degree, when we started adopting LLMs more, it would all be a waste of time, where reading the curriculum and the documentation they provided would be better.

## Applying this in my day job

Whenever you start on a new project, there is often a large codebase that needs to be handled. Not just that, but the technologies that are being used aren't often something that is adopted by everyone, and most importantly, they may be new to you.

The fact that you don't have to spend more than a day reading documentation, and can actually start coding is great.

On the contrary, I've had peers spend hours looking for the "perfect" tutorial when the official documentation would have answered their question in 10 minutes.

I will say this. I fully understand the appeal of videos. It is a more pleasant way of learning, and it is quite enjoyable. I do spend a lot of time outside of work watching the same type of videos. The only problem is that I don't get the same learning takeaways from it.

## Applying it for side projects

The other benefit of this is learning new libraries and technologies. Reading the docs lets you try new technologies and get started with them, without having to wait for your favorite content creator to make a video on it.

Being comfortable with documentation means you're not waiting for someone else to digest and repackage information for you – you can jump on new tech right away.

## Conclusions

When working now, I've realized that you have to read a lot of documentation, so getting good at it is a big benefit. LLMs can help in some cases, but I have often seen that they just waste my time, and it results in me reading the docs anyway.

In the end, just read the docs! It's really not that bad, and you save more time by doing so.
